name: Publish changed modules

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      scope:
        description: Publish changed modules from the latest change-set or all modules
        required: true
        default: changed
        type: choice
        options:
          - changed
          - all

permissions:
  contents: write

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.detect.outputs.matrix }}
      has_modules: ${{ steps.detect.outputs.has_modules }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect modules to publish
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          mode="changed"
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            mode="${{ inputs.scope }}"
          fi

          changed_file_list="$CHANGED_FILE_LIST"
          : > "$changed_file_list"

          if [ "$mode" = "all" ]; then
            : > "$changed_file_list"
          else
            before_sha="${{ github.event.before }}"

            if [ -z "$before_sha" ] || [ "$before_sha" = "0000000000000000000000000000000000000000" ]; then
              if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
                before_sha="$(git rev-parse HEAD^)"
              else
                before_sha=""
              fi
            fi

            if [ -n "$before_sha" ]; then
              git diff --name-only "$before_sha" "$GITHUB_SHA" > "$changed_file_list"
            else
              git ls-tree -r --name-only "$GITHUB_SHA" > "$changed_file_list"
            fi
          fi

          detect_json="$(python - <<'PY'
          import glob
          import json
          import os
          import re

          mode = os.environ["MODE"]
          changed_file_list = os.environ["CHANGED_FILE_LIST"]

          changed_files = None
          if mode != "all":
            with open(changed_file_list, encoding="utf-8") as handle:
              changed_files = set(line.strip() for line in handle if line.strip())

          modules = []
          for manifest in sorted(glob.glob("*/module.json")):
            module_dir = manifest.split("/")[0]

            if changed_files is not None:
              prefix = f"{module_dir}/"
              module_changed_paths = [path for path in changed_files if path.startswith(prefix)]
              if not module_changed_paths:
                continue

              release_relevant_paths = [
                path
                for path in module_changed_paths
                if not re.fullmatch(fr"{re.escape(module_dir)}/(?:README\.md|CHANGELOG\.md)", path, flags=re.IGNORECASE)
              ]

              if not release_relevant_paths:
                continue

            with open(manifest, encoding="utf-8") as handle:
              data = json.load(handle)

            module_id = str(data.get("id", "")).strip()
            version_raw = str(data.get("version", "")).strip()

            if not module_id or not version_raw:
              raise SystemExit(f"Invalid module manifest: {manifest} (id/version required)")

            tag_version = version_raw if version_raw.startswith("v") else f"v{version_raw}"
            modules.append({
              "module_dir": module_dir,
              "module_id": module_id,
              "version": version_raw,
              "tag": f"{module_dir}/{tag_version}"
            })

          print(json.dumps(modules, separators=(",", ":")))
          PY
          )"

          has_modules="false"
          if [ "$detect_json" != "[]" ]; then
            has_modules="true"
          fi

          echo "matrix={\"include\":$detect_json}" >> "$GITHUB_OUTPUT"
          echo "has_modules=$has_modules" >> "$GITHUB_OUTPUT"
        env:
          MODE: ${{ github.event_name == 'workflow_dispatch' && inputs.scope || 'changed' }}
          CHANGED_FILE_LIST: ${{ runner.temp }}/changed-files.txt

  publish:
    runs-on: ubuntu-latest
    needs: detect
    if: needs.detect.outputs.has_modules == 'true'
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.detect.outputs.matrix) }}
    concurrency:
      group: publish-modules-latest
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate module manifest
        shell: bash
        run: |
          set -euo pipefail
          python -m json.tool "${{ matrix.module_dir }}/module.json" > /dev/null

      - name: Create module tag (record-keeping)
        shell: bash
        env:
          PUBLISH_SCOPE: ${{ github.event_name == 'workflow_dispatch' && inputs.scope || 'changed' }}
        run: |
          set -euo pipefail
          tag="${{ matrix.tag }}"

          git fetch --tags --force

          if git rev-parse -q --verify "refs/tags/$tag" >/dev/null 2>&1; then
            tag_sha="$(git rev-list -n 1 "$tag")"
            if [ "$tag_sha" != "$GITHUB_SHA" ]; then
              if [ "$PUBLISH_SCOPE" = "all" ]; then
                echo "Tag '$tag' already exists at $tag_sha (scope=all; skipping integrity check, tag stays put)."
              else
                echo "Tag '$tag' already exists and points to a different commit ($tag_sha)."
                echo "Refusing to publish to preserve release audit integrity."
                exit 1
              fi
            else
              echo "Tag '$tag' already exists for this commit. Continuing idempotent publish."
            fi
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git tag "$tag" "$GITHUB_SHA"
          git push origin "$tag"

      - name: Package module assets
        id: package
        shell: bash
        run: |
          set -euo pipefail
          module_dir="${{ matrix.module_dir }}"
          module_id="${{ matrix.module_id }}"

          mkdir -p dist
          cp "$module_dir/module.json" "dist/${module_id}-module.json"

          python - <<'PY'
          import html as html_lib
          import json
          import re
          import urllib.request

          module_dir = "${{ matrix.module_dir }}"
          module_id = "${{ matrix.module_id }}"

          with open(f"{module_dir}/module.json", encoding="utf-8") as handle:
            manifest = json.load(handle)

          verified = str(manifest.get("compatibility", {}).get("verified", "")).strip()
          if not verified or "." not in verified:
            raise SystemExit(f"Missing or invalid compatibility.verified in {module_dir}/module.json")

          request = urllib.request.Request(
            "https://foundryvtt.com/releases/",
            headers={"User-Agent": "Mozilla/5.0 (compatible; FoundryVTT-BadgeBot/1.0)"}
          )
          with urllib.request.urlopen(request, timeout=20) as response:
            releases_html = response.read().decode("utf-8", errors="ignore")

          plain_text = re.sub(r"(?is)<script.*?>.*?</script>", " ", releases_html)
          plain_text = re.sub(r"(?is)<style.*?>.*?</style>", " ", plain_text)
          plain_text = re.sub(r"<[^>]+>", " ", plain_text)
          plain_text = html_lib.unescape(plain_text)
          plain_text = re.sub(r"\s+", " ", plain_text).strip()

          stable_versions = []
          for match in re.finditer(r"Release\s+(\d+\.\d+)", plain_text, re.IGNORECASE):
            version = match.group(1)
            lookahead = plain_text[match.end():match.end() + 120]
            if not re.search(r"\b(?:Update|Full)\s+Stable\b", lookahead, re.IGNORECASE):
              continue

            major_str, minor_str = version.split(".", 1)
            stable_versions.append((int(major_str), int(minor_str), version))

          verified_major_str, verified_minor_str = verified.split(".", 1)
          verified_major = int(verified_major_str)
          verified_minor = int(verified_minor_str)

          if not stable_versions:
            latest_major = verified_major
            latest_minor = verified_minor
            latest_stable = verified
            color = "yellow"
            print("Warning: Unable to parse stable releases from https://foundryvtt.com/releases/; defaulting badge color to yellow.")
          else:
            latest_major, latest_minor, latest_stable = max(stable_versions)

            if verified_major == latest_major and verified_minor == latest_minor:
              color = "brightgreen"
            elif verified_major == latest_major:
              color = "yellow"
            else:
              color = "red"

          badge = {
            "schemaVersion": 1,
            "label": "Foundry verified",
            "message": verified,
            "color": color,
            "cacheSeconds": 3600
          }

          with open(f"dist/{module_id}-foundry-verified-badge.json", "w", encoding="utf-8") as handle:
            json.dump(badge, handle, separators=(",", ":"))

          print(f"Computed badge for {module_id}: verified={verified}, latest_stable={latest_stable}, color={color}")
          PY

          (
            cd "$module_dir"
            zip -r "../dist/${module_id}.zip" . \
              -x "*.DS_Store" \
              -x "*.git*" \
              -x "node_modules/*" \
              -x "tests/*" \
              -x "tools/*" \
              -x ".vscode/*" \
              -x ".copilot/*"
          )

          echo "module_id=${module_id}" >> "$GITHUB_OUTPUT"

      - name: Publish versioned release assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ matrix.tag }}
          files: |
            dist/${{ steps.package.outputs.module_id }}-module.json
            dist/${{ steps.package.outputs.module_id }}-foundry-verified-badge.json
            dist/${{ steps.package.outputs.module_id }}.zip
          overwrite_files: true
          make_latest: false

      - name: Move modules-latest tag to current commit
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --force
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -f modules-latest "$GITHUB_SHA"
          git push --force origin refs/tags/modules-latest

      - name: Update rolling latest module assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: modules-latest
          name: Latest Module Assets
          files: |
            dist/${{ steps.package.outputs.module_id }}-module.json
            dist/${{ steps.package.outputs.module_id }}-foundry-verified-badge.json
            dist/${{ steps.package.outputs.module_id }}.zip
          overwrite_files: true
          make_latest: true

  no-changes:
    runs-on: ubuntu-latest
    needs: detect
    if: needs.detect.outputs.has_modules != 'true'
    steps:
      - name: No changed modules
        run: echo "No module folder changes detected; nothing to publish."

  sync-badges:
    runs-on: ubuntu-latest
    needs: [detect, publish]
    if: needs.detect.outputs.has_modules == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Regenerate Foundry verified badge files
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import glob
          import html as html_lib
          import json
          import re
          import urllib.request

          request = urllib.request.Request(
            "https://foundryvtt.com/releases/",
            headers={"User-Agent": "Mozilla/5.0 (compatible; FoundryVTT-BadgeBot/1.0)"}
          )
          with urllib.request.urlopen(request, timeout=20) as response:
            releases_html = response.read().decode("utf-8", errors="ignore")

          plain_text = re.sub(r"(?is)<script.*?>.*?</script>", " ", releases_html)
          plain_text = re.sub(r"(?is)<style.*?>.*?</style>", " ", plain_text)
          plain_text = re.sub(r"<[^>]+>", " ", plain_text)
          plain_text = html_lib.unescape(plain_text)
          plain_text = re.sub(r"\s+", " ", plain_text).strip()

          stable_versions = []
          for match in re.finditer(r"Release\s+(\d+\.\d+)", plain_text, re.IGNORECASE):
            version = match.group(1)
            lookahead = plain_text[match.end():match.end() + 120]
            if not re.search(r"\b(?:Update|Full)\s+Stable\b", lookahead, re.IGNORECASE):
              continue
            major_str, minor_str = version.split(".", 1)
            stable_versions.append((int(major_str), int(minor_str), version))

          os_path = ".github/badges"
          import os
          os.makedirs(os_path, exist_ok=True)

          for manifest_path in sorted(glob.glob("*/module.json")):
            module_dir = manifest_path.split("/")[0]
            with open(manifest_path, encoding="utf-8") as handle:
              manifest = json.load(handle)

            module_id = str(manifest.get("id", "")).strip()
            verified = str(manifest.get("compatibility", {}).get("verified", "")).strip()
            if not module_id or not verified or "." not in verified:
              continue

            verified_major_str, verified_minor_str = verified.split(".", 1)
            verified_major = int(verified_major_str)
            verified_minor = int(verified_minor_str)

            if not stable_versions:
              latest_stable = verified
              color = "yellow"
            else:
              latest_major, latest_minor, latest_stable = max(stable_versions)
              if verified_major == latest_major and verified_minor == latest_minor:
                color = "brightgreen"
              elif verified_major == latest_major:
                color = "yellow"
              else:
                color = "red"

            badge = {
              "schemaVersion": 1,
              "label": "Foundry verified",
              "message": verified,
              "color": color,
              "cacheSeconds": 3600
            }

            out_path = f".github/badges/{module_id}-foundry-verified-badge.json"
            with open(out_path, "w", encoding="utf-8") as handle:
              json.dump(badge, handle, separators=(",", ":"))

            print(f"Synced {out_path}: verified={verified}, latest_stable={latest_stable}, color={color}")
          PY

      - name: Commit badge file updates
        shell: bash
        run: |
          set -euo pipefail
          if git diff --quiet -- .github/badges; then
            echo "No badge file changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .github/badges
          git commit -m "Update Foundry verified badge files [skip ci]"
          git push origin HEAD:${GITHUB_REF_NAME}
